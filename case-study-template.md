# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы буду использовать такую метрику:
- Количество итераций в секунду (ips) выполнения программы на данных размером 0,25Мb

Время выполнения исходного кода на файлах разной величины:
```
Calculating -------------------------------------
    Process 0.0625Mb      7.227  (±13.8%) i/s -     35.000  in   5.016108s
     Process 0.125Mb      1.793  (± 0.0%) i/s -      9.000  in   5.179667s
      Process 0.25Mb      0.504  (± 0.0%) i/s -      3.000  in   5.975735s
       Process 0.5Mb      0.146  (± 0.0%) i/s -      1.000  in   6.864431s
         Process 1Mb      0.039  (± 0.0%) i/s -      1.000  in  25.710734s
         Process 2Mb      0.009  (± 0.0%) i/s -      1.000  in 109.083634s

Comparison:
    Process 0.0625Mb:        7.2 i/s
     Process 0.125Mb:        1.8 i/s - 4.03x  slower
      Process 0.25Mb:        0.5 i/s - 14.34x  slower
       Process 0.5Mb:        0.1 i/s - 49.61x  slower
         Process 1Mb:        0.0 i/s - 185.80x  slower
         Process 2Mb:        0.0 i/s - 788.29x  slower
```
Тенденция: при увеличении обьема исходных данных в два раза, время заметляется в 4 раза.

Функция растет очерь быстро, надо разбираться с алгоритмом.

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за время ~5 секунд.

Вот как я построил `feedback_loop`:
- тестовый файл 0,25Мb, исходное время выполнения 5 секунд
- поиск самого узкого места
- улучшение кода
- замеры метрик
- запуск тестов
- анализ результатов

Исходная программа имеет метрику **~0.504ips**

## Вникаем в детали системы, чтобы найти 20% точек роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался библиотеками benchmark, ruby-prof, Valgrind, stackprof.

Вот какие проблемы удалось найти и решить

### Valgrind massif
Профиль использования памяти на файле 0,25Мb
`valgrind --tool=massif ruby task-2.rb`
![image massif](https://a.radikal.ru/a22/1903/7f/47d630ea9c4d.jpg)

### Ваша находка №1
О вашей находке №1

### Ваша находка №2
О вашей находке №2

### Ваша находка №X
О вашей находке №X

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с *того, что у вас было в начале, до того, что получилось в конце*

*Какими ещё результами можете поделиться*

## Защита от регресса производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы сделано *то, что вы для этого сделали*
